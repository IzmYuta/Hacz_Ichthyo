# 変更サマリ（放送型への要点）

* **常時発話の“ホスト・エージェント”**をサーバ側で**24時間起動**し、音声トラックを**配信（Publish）**。
* 視聴者は**そのトラックを購読（Subscribe）**するだけで**即“今この瞬間”に合流**（巻き戻しなし）。
* 視聴者の**PTT 入力はキュー化**し、**優先度制御＋ダッキング**で**ホストへ割り込み**（質問→応答→復帰）。
* アーキは**WebRTC SFU（LiveKit など）**を中継に据え、**OpenAI Realtime**は**サーバ常駐1セッション**で運用。
* **番組進行ループ（Program Director）**が**時報テーマ／コーナー／BGM／ニュース**を自動進行。

---

# 全体アーキテクチャ（放送型 v2）

```mermaid
flowchart LR
  subgraph Client (Listener)
    UI[Next.js 15 + React 19 (PWA)]
    UI -->|Subscribe| SFU[(WebRTC SFU: LiveKit)]
    UI --> PTT[PTT 音声/テキスト投稿]
    PTT --> WS[WS: 投稿→Go API]
  end

  subgraph Server
    API[Go API + WS] --> DB[(PostgreSQL + pgvector)]
    API --> Dir[Program Director(番組進行)]
    API --> Mixer[Audio Mixer / Ducking]
    API --> SFU
  end

  subgraph OpenAI
    RT[Realtime API (gpt-realtime)]
  end

  Host[Host Agent (常時発話)] -->|Pub 音声| SFU
  Host <-.-> Mixer
  Host <-.WebRTC/Events.-> RT
  Dir <-.tools/mcp.-> API
  Dir --> Host
```

**ポイント**

* **Host Agent**（常時発話 AI）は**サーバ側で常駐**。**RT（Realtime）**と**WebRTC**で接続し、**音声アウト**を**SFUへ Publish**。
* **Listener**は**SFUに接続して即再生**。各ユーザーが OpenAI に直接張らないので**コストとスケールが安定**。
* **PTT**は**Go API に集約**→**発話順序の仲裁（Queue）**→**Host へ順次注入**。**Mixer**で**BGM/ジングル/ダッキング**を制御。
* **Program Director**が**テーマ/ニュース/ジングル**等の**進行**と**Host のプロンプト更新**を司る。

---

# 主要コンポーネント（新規/変更）

## 1) Host Agent（常時発話 AI）

* **役割**：24時間しゃべり続ける“パーソナリティ”。
* **実体**：サーバ内プロセス（Go でも Node でも可）＋ Realtime への**単一長時間セッション**。
* **発話継続の工夫**

  * **進行プロンプト**を**Program Director**が**5〜15秒ごと**に更新（次トピック、ジングル、時報切替アナウンスなど）。
  * **無音回避**：質問が無い時は**用意した台本/ニュース/メッセ**で自然に喋る。
  * **フェイルオーバ**：RT 切断時は\*\*TTS バックアップ（短いつなぎ）\*\*で復帰アナウンス。

## 2) Program Director（番組進行ループ）

* **毎正時**に**テーマ切替**、**15分刻み**で**コーナー進行**、「投稿募集→回答→ジングル→次コーナ」までを**状態遷移**で管理。
* **外部情報**（天気/ニュース/社内FAQ など）は**MCP/関数呼び出し**で取得 → Host プロンプトへインジェクト。
* **台本スロット**：`OP -> TopicA -> TopicB -> 投稿Q&A -> CM/ジングル -> 時報`
* **UI 連動**：進行状態を**WS**で Front へ配信（テーマ色、NowPlaying、字幕）。

## 3) Audio Mixer / Ducking

* **機能**：ホスト発話を**常時 Publish**、**PTT 受話時は自動ダッキング**（-12〜-18dB）し、**Q\&A**をミックス。
* **実装**：

  * **SFU 側ミキサ**（LiveKit の RoomComposite / サーバメディア処理）
  * or **サーバ内 GStreamer/FFmpeg** で**ホスト音声**と**コーラー音声**を**合成→単一配信**。
* **利点**：**1トラック配信**で**視聴者台数に依存せず安定**、録音・クリップ化も容易。

## 4) PTT Ingress（投稿キュー）

* **PTT（音声/テキスト）**→**/ws/ptt**へ送信→**Queue**へ
* **優先度**：電話>招待ユーザー>一般、**最大同時 1 名**（放送品質維持）
* **ホスト割り込み**：進行ステートが`QANDA`のときのみ割り込み許可等、**状態機械で仲裁**。

---

# セッション/配信の具体

* **OpenAI Realtime**は**サーバ常駐 1 セッション**（Host 用）。

  * **server VAD / idle timeout**は**無効 or 長め**に設定し、**Program Director**から明示的に話題を投げて“喋らせる”。
  * **指示**は**function call / input\_audio\_buffer**で逐次注入。
* **Listener**は**OpenAI へ接続しない**。**SFU**（LiveKit）に**Subscribe**だけ。

  * モバイル/ブラウザ双方で**超低遅延（\~200–400ms）**。
  * 視聴者数増でも**Host セッションは 1**なので**コスト一定**。

---

# API/イベント設計（増分）

```http
# Ephemeral は不要（Listener は OpenAI に直結しないため）
# 代わりに LiveKit/SFU の Join Token を発行
POST /api/room/join
- auth済 → {token, url, room:"radio-24", subscribeOnly:true}

WS /ws/ptt
- {type:"offer", media:"audio" | "text", text?, opusFrame?}
- サーバ側でASR→Transcript→Queueに積む

POST /api/admin/program/advance
- 手動で状態遷移（デモ用フェイルセーフ）

GET /api/now
- {theme, segment, listeners, nowPlaying, nextJingleAt}
```

**内部イベント（Server → Host/Director/Mixer）**

* `EVENT.PTT_ENQUEUED` / `EVENT.PTT_DEQUEUED` / `EVENT.PTT_TIMEOUT`
* `EVENT.TOP_OF_HOUR`（時報）/ `EVENT.SEGMENT_TICK`
* `EVENT.MIXER_DUCK_ON` / `EVENT.MIXER_DUCK_OFF`
* `EVENT.RT_RECONNECTED`

---

# データモデル（追加/変更）

```mermaid
erDiagram
  USER ||--o{ SUBMISSION : makes
  CHANNEL ||--o{ CLIP : has
  CHANNEL {
    uuid id PK
    text name        // "Radio-24"
    bool live        // 常時 true
    timestamptz started_at
  }
  SCHEDULE {
    uuid id PK
    uuid channel_id
    int hour        // 0..23
    text block      // "OP","NEWS","QANDA","MUSIC"
    text prompt     // 進行用ガイダンス
  }
  QUEUE {
    uuid id PK
    uuid user_id
    text kind       // audio|text|phone
    text text       // transcript
    jsonb meta      // priority, phoneNumber等
    timestamptz enqueued_at
    text status     // queued|live|done|dropped
  }
```

* **CHANNEL**：将来チャンネル増やす下地（音楽枠/英語枠など）
* **SCHEDULE**：**Program Director**の台本/ガイダンスの**時間割**
* **QUEUE**：PTT 入力の**優先度と状態管理**

---

# 進行プロンプト例（常時発話用・要約）

> システム：あなたは24時間ラジオのメインパーソナリティ。放送は切れ目なく続く。
> いまのテーマ：{theme}、このセグメント：{segment}（残り{mm\:ss}）。
> 投稿キュー：{top3}（名前/要約/優先度）。
> ルール：
>
> * 無音を作らない。**15秒以上の沈黙は禁止**。
> * 聴き取りやすい**短文**で、**要約を字幕**に残す。
> * Q\&A中は**回答→要約→次Q**の順。
> * セグメント終了30秒前に**クロージング**、時報で**次テーマ宣言**。
> * NGワード/個人情報は読み上げない。
> * エラー時は「機材トラブル」と一言入れてから復旧。

---

# フロント変更点（最低限）

* **/on-air**：

  * **Subscribe-only Join**（LiveKit Token を API から取得→即再生）
  * **PTT ボタン**：押下中のみ録音→`/ws/ptt` へ送出
  * **NowPlaying/字幕/視聴者数**を WS で表示
* **/submit**：テキスト投稿→Queue
* **/clips**：録画から1分ダイジェスト（自動）

---

# 実装ステップ（最速デモ導線）

1. **LiveKit(SFU) 部署** → **Server Publisher** を立てて**ダミーTTS**を常時配信
2. **Host Agent** を Realtime へ接続し、**番組ガイダンスで独り喋り**開始
3. **Listener Join** 実装（Subscribe Only）→**即再生**
4. **PTT Queue** → **割り込み回答**（Mixer ダッキング）
5. **毎正時テーマ切替**（UI色/ジングル/発話トピック）
6. **クリップ自動生成**（24連ショート）

---

# 運用・可用性

* **監視**：Host 心拍（10s ping）、RT 再接続／LiveKit Track 再公開
* **冗長**：**ホットスタンバイ Host**（片方ミュート、フェイル時に切替）
* **コスト**：視聴者増は**SFU 横スケール**で吸収、**OpenAI 接続は1**で安定
* **法務**：投稿の**モデレーション**、録音の**同意**（画面上に掲示）

---

# サンプル：Go（概念コード・重要部のみ）

```go
// PTTをキューへ
type PTTMsg struct {
  UserID string `json:"user_id"`
  Kind   string `json:"kind"`  // "audio"|"text"|"phone"
  Text   string `json:"text,omitempty"`
  // audio は別チャネルで受け取りASR
}

func (h *WSHandler) OnPTT(msg PTTMsg) {
  // 優先度付与 → Queueへ
  // 状態がQANDAの時だけDEQUEUEしてHostへ inject
}

// ディレクターのティック
func (d *Director) Tick(now time.Time) {
  if topOfHour(now) { d.SwitchTheme(now.Hour()) }
  d.advanceSegment()
  d.pushNowPlayingToUI()
  d.updateHostPrompt()
}
```

---

# なぜこの方式が“放送”に最適か

* **常時発話**は**1人（1セッション）**のほうが**途切れず安定**。
* 視聴者は**SFUに合流**するだけで“今”を聴ける＝**ラジオ体験**。
* **PTT 割り込み**を**Queue と状態機械**で整理できるので、**品位のある生放送**に。
* **録音・名場面抽出**が**1本の配信トラック**から容易。

---

# マイグレーション指針（元仕様 → 放送型）

1. **WebRTC 直 to OpenAI（各視聴者）**を**廃止**し、**サーバ常駐 Host → SFU 配信**へ一本化
2. **Ephemeral 発行 API**は**LiveKit Join Token API**へ置き換え
3. **毎正時テーマ**は Realtime へのインライン指示ではなく、**Director が一元管理**
4. **pgvector**は**投稿類似／ハイライト選定**に継続使用
5. **SIP/電話**は**Server→SFU の別 Publisher**として取り込み、**Queue 優先度＝最上位**に設定

